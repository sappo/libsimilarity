################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################

from __future__ import print_function
import os
import re
import sys

from cffi import FFI

ffi = FFI()

try:
    # If LD_LIBRARY_PATH or your OSs equivalent is set, this is the only way to
    # load the library.  If we use find_library below, we get the wrong result.
    if os.name == 'posix':
        if sys.platform == 'darwin':
            libpath = 'libharry.0.dylib'
        else:
            libpath = 'libharry.so.0'
    elif os.name == 'nt':
        libpath = 'libharry.dll'
    lib = ffi.dlopen(libpath)
except OSError:
    libpath = find_library("harry")
    if not libpath:
        raise ImportError("Unable to find libharry")
    lib = ffi.dlopen(libpath)

# Custom setup for harry


cdefs = '''
typedef struct _hstring_t hstring_t;
typedef struct _measures_t measures_t;
// Init function for similarity measure implementations
typedef void (measures_config_fn) (
    measures_t *self);

// Compare function for similarity measure implementations. Returns
// distance or simularity measure.                                 
typedef float (measures_compare_fn) (
    measures_t *self, hstring_t *x, hstring_t *y);

// CLASS: hstring
// Converts a c-style string into a string object.
hstring_t *
    hstring_new (const char *str);

// Creates an empty string object.
hstring_t *
    hstring_empty (int type);

// Destroy the string object.
void
    hstring_destroy (hstring_t **self_p);

// Decodes a string containing delimiters into a lookup table.
void
    hstring_delim_set (const char *str);

// Check whether delimiters have been set. Returns true if delimiters have
// been set, otherwise false.                                             
int
    hstring_has_delim (void);

// Resets delimiters table. There is a global table of delimiter symbols
// which is only initialized once the first sequence is processed. This 
// functions is used to trigger a re-initialization.                    
void
    hstring_delim_reset (void);

// 
void
    hstring_preproc (hstring_t *self, measures_t *measure);

// Converts a string into a sequence of tokens using delimiter characters.
// The original character string is lost. Returns 0 if successful,        
// otherwise -1.                                                          
int
    hstring_tokenify (hstring_t *self);

// Converts a string into a sequence of bits. Well, actually there is no
// conversion except for that the counting now happens on the level of  
// bits instead of bytes.                                               
void
    hstring_bitify (hstring_t *self);

// Computes a 64-bit hash for a substring. Collisions are possible but not
// very likely (hopefully). Returns 64-bit hash.                          
uint64_t
    hstring_hash_sub (hstring_t *self, int start, int len);

// Computes a 64-bit hash for a string. The hash is used at different  
// locations.  Collisions are possible but not very likely (hopefully).
// Returns 64-bit hash.                                                
uint64_t
    hstring_hash1 (hstring_t *self);

// Computes a 64-bit hash for two strings. The computation is symmetric,  
// that is, the same strings retrieve the same hash independent of their  
// order.  Collisions are possible but not very likely (hopefully). Return
// 64-bit hash.                                                           
uint64_t
    hstring_hash2 (hstring_t *x, hstring_t *y);

// Returns symbol/character at given position.
uint64_t
    hstring_get (hstring_t *self, int pos);

// Perform a soundex transformation of each token.                       
//                                                                       
// Soundex code as implemented by Kevin Setter, 8/27/97 with some slight 
// modifications. Known bugs: Consonants separated by a vowel are treated
// as one character, if they have the same index. This is wrong. :(      
void
    hstring_soundex (hstring_t *self);

// Compares two symbols/characters. Returns 0 if equal, < 0 if x smaller,
// > 0 if y smaller                                                      
int
    hstring_compare (hstring_t *x, int posx, hstring_t *y, int posy);

// Print string object
void
    hstring_print (hstring_t *self);

// Reads stop tokens from file and hash them.
void
    hstring_stoptokens_load (const char *filename);

// Destroys stop tokens table.
void
    hstring_stoptokens_destroy (void);

// Self test of this class.
void
    hstring_test (bool verbose);

// CLASS: measures
// Creates a new measures instance for the given measure function. Return 
// a measures instance initialized with measure function default values or
// NULL if measure function could not be found.                           
measures_t *
    measures_new (const char *function);

// Destroys a measures instance.
void
    measures_destroy (measures_t **self_p);

// Compares two strings with the given similarity measure. Returns
// similarity/dissimilarity value.                                
float
    measures_compare (measures_t *self, hstring_t *x, hstring_t *y);

// Sets a string configuration
void
    measures_config_set_string (measures_t *self, const char *key, const char *value);

// Sets an integer configuration
void
    measures_config_set_int (measures_t *self, const char *key, const int value);

// Sets an float configuration
void
    measures_config_set_float (measures_t *self, const char *key, const float value);

// Sets an integer configuration
void
    measures_config_set_bool (measures_t *self, const char *key, const bool value);

// Finds best matching measure for name. Returns index of measure found,
// otherwise 0.                                                         
int
    measures_match (const char *name);

// Configures the measure for a given similarity measure with its default
// values. Returns the name of the selected similarity measure           
char *
    measures_config (measures_t *self, const char *name);

// Self test of this class.
void
    measures_test (bool verbose);

'''
cdefs = re.sub(r';[^;]*\bva_list\b[^;]*;', ';', cdefs, flags=re.S) # we don't support anything with a va_list arg

ffi.set_source("harry_cffi", None)
ffi.cdef(cdefs)

ffiwrapper = FFI()
ffiwrapper.cdef('''
void
   hstring_destroy_py (void *self);

void
   measures_destroy_py (void *self);

''')

ffiwrapper.set_source("harry_py_destructors",
                      libraries=['harry'], source='''
#include <harry.h>
void
hstring_destroy_py (void *self)
{
   hstring_destroy ((hstring_t **) &self);
}

void
measures_destroy_py (void *self)
{
   measures_destroy ((measures_t **) &self);
}

''')

if __name__ == "__main__":
    ffi.compile()
    ffiwrapper.compile()
