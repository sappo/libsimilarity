################################################################################
#  THIS FILE IS 100% GENERATED BY ZPROJECT; DO NOT EDIT EXCEPT EXPERIMENTALLY  #
#  Read the zproject/README.md for information about making permanent changes. #
################################################################################
from .harry_cffi import ffi
from .harry_py_destructors import lib as libwrapper
from .build_harry_cffi import lib
from .utils import *


class Hstring(object):
    """
    String object with functions for processing strings and sequences
    """

    def __init__(self, str):
        """
        Converts a c-style string into a string object.
        """
        p = lib.hstring_new(to_bytes(str))
        if p == ffi.NULL:
            raise MemoryError("Could not allocate person")

        # ffi.gc returns a copy of the cdata object which will have the
        # destructor called when the Python object is GC'd:
        # https://cffi.readthedocs.org/en/latest/using.html#ffi-interface
        self._p = ffi.gc(p, libwrapper.hstring_destroy_py)


    def delim_set(str):
        """
        Decodes a string containing delimiters into a lookup table.
        """
        return lib.hstring_delim_set(to_bytes(str))

    def has_delim():
        """
        Check whether delimiters have been set. Returns true if delimiters have
        been set, otherwise false.                                             
        """
        return lib.hstring_has_delim()

    def delim_reset():
        """
        Resets delimiters table. There is a global table of delimiter symbols
        which is only initialized once the first sequence is processed. This 
        functions is used to trigger a re-initialization.                    
        """
        return lib.hstring_delim_reset()

    def preproc(self, measure):
        """
        
        """
        return lib.hstring_preproc(self._p, measure._p)

    def tokenify(self):
        """
        Converts a string into a sequence of tokens using delimiter characters.
        The original character string is lost. Returns 0 if successful,        
        otherwise -1.                                                          
        """
        return lib.hstring_tokenify(self._p)

    def bitify(self):
        """
        Converts a string into a sequence of bits. Well, actually there is no
        conversion except for that the counting now happens on the level of  
        bits instead of bytes.                                               
        """
        return lib.hstring_bitify(self._p)

    def hash_sub(self, start, len):
        """
        Computes a 64-bit hash for a substring. Collisions are possible but not
        very likely (hopefully). Returns 64-bit hash.                          
        """
        return lib.hstring_hash_sub(self._p, start, len)

    def hash1(self):
        """
        Computes a 64-bit hash for a string. The hash is used at different  
        locations.  Collisions are possible but not very likely (hopefully).
        Returns 64-bit hash.                                                
        """
        return lib.hstring_hash1(self._p)

    def hash2(x, y):
        """
        Computes a 64-bit hash for two strings. The computation is symmetric,  
        that is, the same strings retrieve the same hash independent of their  
        order.  Collisions are possible but not very likely (hopefully). Return
        64-bit hash.                                                           
        """
        return lib.hstring_hash2(x._p, y._p)

    def get(self, pos):
        """
        Returns symbol/character at given position.
        """
        return lib.hstring_get(self._p, pos)

    def soundex(self):
        """
        Perform a soundex transformation of each token.                       
                                                                              
        Soundex code as implemented by Kevin Setter, 8/27/97 with some slight 
        modifications. Known bugs: Consonants separated by a vowel are treated
        as one character, if they have the same index. This is wrong. :(      
        """
        return lib.hstring_soundex(self._p)

    def compare(x, posx, y, posy):
        """
        Compares two symbols/characters. Returns 0 if equal, < 0 if x smaller,
        > 0 if y smaller                                                      
        """
        return lib.hstring_compare(x._p, posx, y._p, posy)

    def print(self):
        """
        Print string object
        """
        return lib.hstring_print(self._p)

    def stoptokens_load(filename):
        """
        Reads stop tokens from file and hash them.
        """
        return lib.hstring_stoptokens_load(to_bytes(filename))

    def stoptokens_destroy():
        """
        Destroys stop tokens table.
        """
        return lib.hstring_stoptokens_destroy()

    def test(verbose):
        """
        Self test of this class.
        """
        return lib.hstring_test(verbose)

